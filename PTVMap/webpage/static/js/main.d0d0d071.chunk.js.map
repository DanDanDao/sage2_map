{"version":3,"sources":["useSAGE2AppState.js","modules/departures.js","components/leaflet-icons/train-icon/train-side-delayed-icon.js","components/leaflet-icons/train-icon/train-side-inverted-delayed.js","components/leaflet-icons/rail-icon/rail-icon.js","components/leaflet-icons/train-icon/train-icon.js","components/leaflet-icons/train-icon/train-side-icon.js","components/leaflet-icons/train-icon/train-side-inverted-icon.js","components/leaflet-icons/RotatedMarker.js","views/Map/Map.js","views/Debug/Debug.js","App.js","serviceWorker.js","index.js","SAGE2_AppState.js","assets/icons/train_side_delayed.svg","assets/icons/train_side_inverted_delayed.svg","assets/icons/rail2.svg","assets/icons/train.png","assets/icons/train_side.svg","assets/icons/train_side_inverted.svg"],"names":["SAGE2AppStateContext","React","createContext","SAGE2App","initialState","children","useState","appState","setAppState","useEffect","SAGE2_AppState","state","addFullStateHandler","fullState","Provider","value","require","trainSideDelayedIcon","L","icon","iconUrl","popupAnchor","tooltipAnchor","shadowUrl","shadowSize","shadowAnchor","iconSize","className","trainSideInvertedDelayedIcon","railIcon","trainIcon","trainSideIcon","trainSideInvertedIcon","RotatedMarker","props","el","LeafletMarker","position","this","getOptions","contextValue","leaflet","popupContainer","fromProps","toProps","leafletElement","setLatLng","setIcon","zIndexOffset","setZIndexOffset","opacity","setOpacity","draggable","dragging","enable","disable","rotationAngle","setRotationAngle","rotationOrigin","setRotationOrigin","MapLayer","defaultProps","withLeaflet","axios","moment","swapRouteType","post","getDisruptions","get","params","ID","then","response","container","document","getElementById","innerHTML","delays","data","console","log","i","length","description","showScheduledRuns","scheduledRunsVisible","setState","initialiseRefreshRate","refreshRate","refresh","setInitialRefreshRate","catch","error","displayRefresh","setInterval","updateData","updateRefresh","clearInterval","text","size","displayRefreshSlider","Map","mapRef","createRef","trainRef","stationRef","lat","lng","zoom","routes","stationDepartures","runs","handleZoom","bind","refreshPage","setZoom","zoomOut","zoomIn","all","currZoom","current","viewport","maxZoom","vehicleSize","Math","pow","stationSize","options","layers","getLayers","refreshIconOptions","stop_id","stop","stop_name","route_id","route_name","direction_id","j","directions","direction_name","lateCount","departureCount","stations","departures","estimatedTime","utc","estimated_departure_utc","scheduledTime","scheduled_departure_utc","abs","diff","punctuality","calculatePunctuality","id","ref","scrollWheelZoom","center","onZoomEnd","isNaN","toFixed","onClick","type","defaultValue","DEF_API_REP_FREQ","disabled","min","max","onMouseUp","onChange","TileLayer","attribution","url","maxClusterRadius","map","key","index","departure","currentDeparture","timeStamp","angle","tooltip","arrivalTime","atPlatform","at_platform","runStarted","previousStopCoordinates","coordinates","nextStopCoordinates","currentCoordinates","scalar","timeStampSeconds","prevDeparture","nextDeparture","time1","time2","travelTime","late","xCoordinate","yCoordinate","Departures","latitude","longitude","atan","PI","prevStation","filteredDepartures","filteredDetails","differenceInTime","stopName","returnStopName","push","beginningRun","stoppedAtStation","Tooltip","getRouteName","getDirectionName","run_id","Popup","index3","LayerGroup","stop_latitude","stop_longitude","Marker","index2","schedule","highlight","Component","Debug","stops","runID","stopID","routeID","result1","result2","result3","a","b","aTime","bTime","comparison","isAfter","isBefore","event","target","k","sort","sortDeparturesBasedOnTime","currentTime","departureTime","result","InputGroup","Input","placeholder","evt","handleChangeRunID","Button","returnDepartures","parseInt","color","Card","CardBody","JSON","stringify","handleChangeStopID","returnStopInformation","handleChangeRouteID","returnStops","ZoomUsingState","valueName","useContext","stateSetter","useCallback","newValue","propagateChanges","fullStateHandler","setValue","undefined","Error","useSAGE2AppStateValue","mapZoom","setCount","App","basename","window","location","pathname","exact","path","component","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","registration","unregister","valueHandlers","fullStateCallback","valueTracker","addValueHandler","nameOfValue","callback","setValueMessage","s2","send","titleUpdate","title","callFunctionInContainer","keys","Object","handleValue","nameOfFunction","message","module","exports"],"mappings":"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","file":"static/js/main.d0d0d071.chunk.js","sourcesContent":["import React, { useState, useEffect, useContext, useCallback } from \"react\";\nimport SAGE2_AppState from \"./SAGE2_AppState\";\n\nconst SAGE2AppStateContext = React.createContext({});\n\nexport function SAGE2App({ initialState = {}, children }) {\n  let [appState, setAppState] = useState(initialState);\n\n  useEffect(() => {\n    //set initial if unitialized\n    if (!SAGE2_AppState.state) {\n      SAGE2_AppState.state = initialState;\n    }\n\n    SAGE2_AppState.addFullStateHandler((fullState) => setAppState(fullState));\n\n    return () => {\n      SAGE2_AppState.addFullStateHandler(null);\n    };\n  });\n\n  return (\n    <SAGE2AppStateContext.Provider value={appState}>\n      {children}\n    </SAGE2AppStateContext.Provider>\n  );\n}\n\nexport function useSAGE2AppState(valueName = null) {\n  let state = useContext(SAGE2AppStateContext);\n\n  if (valueName === null) {\n    return state;\n  } else {\n    return state[valueName];\n  }\n}\n\nexport function useSAGE2AppStateValue(valueName) {\n  let state = useContext(SAGE2AppStateContext);\n  let stateSetter = useCallback(\n    (newValue, propagateChanges) => {\n      SAGE2_AppState.fullStateHandler({ ...state, [valueName]: newValue });\n\n      SAGE2_AppState.setValue(valueName, newValue, propagateChanges);\n    },\n    [valueName]\n  );\n\n  if (valueName === undefined) {\n    throw new Error(\"You must specify the name of a state value to read\");\n  } else if (state[valueName] === undefined) {\n    throw new Error(\n      `The state value [${valueName}] does not exist on this app`\n    );\n  } else {\n    return [state[valueName], stateSetter];\n  }\n}\n","const moment = require('moment');\n\nfunction compareDeparturesTime(a, b) {\n    let aTime, bTime;\n    if (a.estimated_departure_utc) {\n        aTime = moment.utc(a.estimated_departure_utc);\n    }\n    else {\n        aTime = moment.utc(a.scheduled_departure_utc);\n    }\n\n    if (b.estimated_departure_utc) {\n        bTime = moment.utc(b.estimated_departure_utc);\n    }\n    else {\n        bTime = moment.utc(b.scheduled_departure_utc);\n    }\n\n    let comparison = 0;\n    if (aTime.isAfter(bTime)) {\n        comparison = 1;\n    } else if (aTime.isBefore(bTime)) {\n        comparison = -1;\n    }\n\n    return comparison;\n}\n\nexport function getUniqueRuns(departures, route_id) {\n    let runs = [];\n\n    for (let i in departures) {\n        for (let j in departures[i]) {\n            if (runs.indexOf(departures[i][j].run_id) === -1 && departures[i][j].route_id === route_id) {\n                runs.push(departures[i][j].run_id);\n            }\n        }\n    }\n\n    return runs;\n\n};\n\nexport function getDeparturesForRuns(runs, departures) {\n    let filteredRuns = [];\n    let run_id;\n\n    for (let a in runs) {\n        run_id = runs[a];\n        let filteredDepartures = [];\n        let direction_id;\n\n        for (let i in departures) {\n            for (let j in departures[i]) {\n                if (departures[i][j].run_id === run_id) {\n                    filteredDepartures.push(departures[i][j]);\n\n                    if (!direction_id) {\n                        direction_id = departures[i][j].direction_id;\n                    }\n                }\n            }\n        }\n\n        if (filteredDepartures.length > 0) {\n            filteredDepartures.sort(compareDeparturesTime);\n\n            filteredRuns.push({\n                run_id: run_id,\n                direction_id: direction_id,\n                departures: filteredDepartures\n            });\n\n        }\n\n    }\n\n    return filteredRuns;\n\n}\n\nexport function determineRunCoordinates(scalar, previousStopCoordinates, nextStopCoordinates) {\n    let xCoordinate;\n    let yCoordinate;\n    if(previousStopCoordinates) {\n        xCoordinate = nextStopCoordinates[0] + scalar * (previousStopCoordinates[0] - nextStopCoordinates[0]);\n        yCoordinate = nextStopCoordinates[1] + scalar * (previousStopCoordinates[1] - nextStopCoordinates[1]);\n    } else {\n        xCoordinate = nextStopCoordinates[0];\n        yCoordinate = nextStopCoordinates[1];\n    }\n    // console.log(\"Prev: \" + previousStopCoordinates);\n    // console.trace();\n    return [xCoordinate, yCoordinate];\n}\n\nexport function calculateAngle(previousStopCoordinates, nextStopCoordinates) {\n\n    let angle;\n\n    if (previousStopCoordinates) {\n        const latitude = nextStopCoordinates[0] - previousStopCoordinates[0];\n        const longitude = nextStopCoordinates[1] - previousStopCoordinates[1];\n        angle = Math.atan(longitude / latitude) * 180 / Math.PI;\n    } else {\n        angle = 0;\n    }\n\n\n    return angle;\n}","import L from 'leaflet';\n\nconst trainSideDelayedIcon = L.icon({\n  iconUrl: require('../../../assets/icons/train_side_delayed.svg'),\n  popupAnchor: [0, -10],\n  tooltipAnchor: [20, 0],\n  shadowUrl: null,\n  shadowSize: null,\n  shadowAnchor: null,\n  iconSize: [20, 20],\n  className: 'train-icon'\n});\n\nexport { trainSideDelayedIcon };\n\n\n// Icon made by\n// <div>Icons made by <a href=\"https://www.freepik.com/\" title=\"Freepik\">Freepik</a> from <a href=\"https://www.flaticon.com/\"\n// title=\"Flaticon\">www.flaticon.com</a> is licensed by <a href=\"http://creativecommons.org/licenses/by/3.0/\"\n// title=\"Creative Commons BY 3.0\" target=\"_blank\">CC 3.0 BY</a></div>","import L from 'leaflet';\n\nconst trainSideInvertedDelayedIcon = L.icon({\n  iconUrl: require('../../../assets/icons/train_side_inverted_delayed.svg'),\n  popupAnchor: [0, -10],\n  tooltipAnchor: [20, 0],\n  shadowUrl: null,\n  shadowSize: null,\n  shadowAnchor: null,\n  iconSize: [20, 20],\n  className: 'train-icon'\n});\n\nexport { trainSideInvertedDelayedIcon };\n\n\n// Icon made by\n// <div>Icons made by <a href=\"https://www.freepik.com/\" title=\"Freepik\">Freepik</a> from <a href=\"https://www.flaticon.com/\"\n// title=\"Flaticon\">www.flaticon.com</a> is licensed by <a href=\"http://creativecommons.org/licenses/by/3.0/\"\n// title=\"Creative Commons BY 3.0\" target=\"_blank\">CC 3.0 BY</a></div>","import L from 'leaflet';\n\nconst railIcon = new L.icon({\n    iconUrl: require('../../../assets/icons/rail2.svg'),\n    popupAnchor: [0, -10],\n    tooltipAnchor: [20, 0],\n    shadowUrl: null,\n    shadowSize: null,\n    shadowAnchor: null,\n    iconSize: [15, 15],\n    className: 'leaflet-div-icon'\n});\n\nexport { railIcon };\n\n\n// Icon made by \n// <div>Icons made by <a href=\"https://www.flaticon.com/authors/kiranshastry\" title=\"Kiranshastry\">Kiranshastry</a> from <a href=\"https://www.flaticon.com/\" \t\t\t    title=\"Flaticon\">www.flaticon.com</a> is licensed by <a href=\"http://creativecommons.org/licenses/by/3.0/\" \t\t\t    title=\"Creative Commons BY 3.0\" target=\"_blank\">CC 3.0 BY</a></div> */}","import L from 'leaflet';\n\nconst trainIcon = new L.icon({\n    iconUrl: require('../../../assets/icons/train.png'),\n    popupAnchor: [0, -10],\n    tooltipAnchor: [20, 0],\n    shadowUrl: null,\n    shadowSize: null,\n    shadowAnchor: null,\n    iconSize: [20, 20],\n    className: 'train-icon'\n});\n\nexport { trainIcon };\n\n\n// Icon made by \n// <div>Icons made by <a href=\"https://www.freepik.com/\" title=\"Freepik\">Freepik</a> from <a href=\"https://www.flaticon.com/\" \t\t\t    \n// title=\"Flaticon\">www.flaticon.com</a> is licensed by <a href=\"http://creativecommons.org/licenses/by/3.0/\" \t\t\t    \n// title=\"Creative Commons BY 3.0\" target=\"_blank\">CC 3.0 BY</a></div>","import L from 'leaflet';\n\nconst trainSideIcon = L.icon({\n    iconUrl: require('../../../assets/icons/train_side.svg'),\n    popupAnchor: [0, -10],\n    tooltipAnchor: [20, 0],\n    shadowUrl: null,\n    shadowSize: null,\n    shadowAnchor: null,\n    iconSize: [20, 20],\n    className: 'train-icon'\n});\n\nexport { trainSideIcon };\n\n\n// Icon made by \n// <div>Icons made by <a href=\"https://www.freepik.com/\" title=\"Freepik\">Freepik</a> from <a href=\"https://www.flaticon.com/\" \t\t\t    \n// title=\"Flaticon\">www.flaticon.com</a> is licensed by <a href=\"http://creativecommons.org/licenses/by/3.0/\" \t\t\t    \n// title=\"Creative Commons BY 3.0\" target=\"_blank\">CC 3.0 BY</a></div>","import L from 'leaflet';\n\nconst trainSideInvertedIcon = new L.icon({\n    iconUrl: require('../../../assets/icons/train_side_inverted.svg'),\n    popupAnchor: [0, -10],\n    tooltipAnchor: [20, 0],\n    shadowUrl: null,\n    shadowSize: null,\n    shadowAnchor: null,\n    iconSize: [20, 20],\n    className: 'train-icon'\n});\n\nexport { trainSideInvertedIcon };\n\n\n// Icon made by \n// <div>Icons made by <a href=\"https://www.freepik.com/\" title=\"Freepik\">Freepik</a> from <a href=\"https://www.flaticon.com/\" \t\t\t    \n// title=\"Flaticon\">www.flaticon.com</a> is licensed by <a href=\"http://creativecommons.org/licenses/by/3.0/\" \t\t\t    \n// title=\"Creative Commons BY 3.0\" target=\"_blank\">CC 3.0 BY</a></div>","import React from 'react';\nimport { Marker as LeafletMarker } from 'leaflet';\nimport { LeafletProvider, withLeaflet, MapLayer } from 'react-leaflet';\nimport 'leaflet-rotatedmarker';\n\nclass RotatedMarker extends MapLayer {\n  static defaultProps = {\n    rotationOrigin: 'center',\n  };\n\n  createLeafletElement(props) {\n    const el = new LeafletMarker(props.position, this.getOptions(props));\n    this.contextValue = { ...props.leaflet, popupContainer: el };\n    return el;\n  }\n\n  updateLeafletElement(fromProps, toProps) {\n    if (toProps.position !== fromProps.position) {\n      this.leafletElement.setLatLng(toProps.position);\n    }\n    if (toProps.icon !== fromProps.icon) {\n      this.leafletElement.setIcon(toProps.icon);\n    }\n    if (toProps.zIndexOffset !== fromProps.zIndexOffset) {\n      this.leafletElement.setZIndexOffset(toProps.zIndexOffset);\n    }\n    if (toProps.opacity !== fromProps.opacity) {\n      this.leafletElement.setOpacity(toProps.opacity);\n    }\n    if (toProps.draggable !== fromProps.draggable) {\n      if (toProps.draggable === true) {\n        this.leafletElement.dragging.enable();\n      } else {\n        this.leafletElement.dragging.disable();\n      }\n    }\n    if (toProps.rotationAngle !== fromProps.rotationAngle) {\n      this.leafletElement.setRotationAngle(toProps.rotationAngle);\n    }\n    if (toProps.rotationOrigin !== fromProps.rotationOrigin) {\n      this.leafletElement.setRotationOrigin(toProps.rotationOrigin);\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    return children == null || this.contextValue == null ? null : (\n      <LeafletProvider value={this.contextValue}>{children}</LeafletProvider>\n    );\n  }\n}\n\nexport default withLeaflet(RotatedMarker);","import React, { Component } from 'react';\nimport { Map as LeafletMap, LayerGroup, TileLayer, Marker, Popup, Tooltip } from 'react-leaflet';\nimport MarkerClusterGroup from 'react-leaflet-markercluster';\nimport Control from 'react-leaflet-control';\nimport { useSAGE2AppStateValue } from \"../../useSAGE2AppState\";\n\nimport './Map.css';\n\n// Importing Submodules\nimport * as Departures from '../../modules/departures';\n\n// Importing Components\nimport { trainSideDelayedIcon} from \"../../components/leaflet-icons/train-icon/train-side-delayed-icon\";\nimport { trainSideInvertedDelayedIcon} from \"../../components/leaflet-icons/train-icon/train-side-inverted-delayed\";\nimport { railIcon } from '../../components/leaflet-icons/rail-icon/rail-icon';\nimport { trainIcon } from '../../components/leaflet-icons/train-icon/train-icon';\nimport { trainSideIcon } from '../../components/leaflet-icons/train-icon/train-side-icon';\nimport { trainSideInvertedIcon } from '../../components/leaflet-icons/train-icon/train-side-inverted-icon';\nimport RotatedMarker from '../../components/leaflet-icons/RotatedMarker';\n\n// Importing Packages\nconst axios = require('axios');\nconst moment = require('moment');\n\n// Icon scaling constants\nconst ICON_SCALE_FACTOR = 3;\nconst MAX_VEHICLE_ICON_LEN = 50;\nconst MAX_STATION_ICON_LEN = 40;\nconst MIN_ICON_SIZE = 10;\n\n// Update frequency\nconst DEF_API_REP_FREQ = 30;\nconst MIN_API_REP_FREQ = 15;\nconst MAX_API_REP_FREQ = 600;\nconst SECONDS_TO_MS = 1000;\n\nfunction getRouteDescriptions() {\n    return axios.get('/api/routes');\n}\n\nfunction getStationDepartures() {\n    return axios.get('/api/stationDepartures');\n}\n\nfunction getRuns() {\n    return axios.get('/api/runs');\n}\n\nfunction swapRouteType() {\n    axios.post('/api/swapRouteType');\n}\n\n//Show disruption for the given station\nfunction getDisruptions(){\n  let myRes = axios.get('/disruptions', {\n        params: {\n          ID: 4\n        }\n      })\n      .then(function (response) {\n        let container = document.getElementById('disruptionsContainer');\n        container.innerHTML = \"\";\n        let delays = response.data['metro_train'];\n        console.log(delays);\n        for (var i = 0; i < delays.length; i++){\n            container.innerHTML += delays[i].description + \"<br>\";\n            console.log(delays[i].description);\n        }\n    })\n}\n\n\nfunction showScheduledRuns() {\n    // Swap color of button based on current visibility\n    if(!this.state.scheduledRunsVisible) {\n        document.getElementById(\"toggleScheduledRuns\").className = \"control activeScheduledRuns\";\n    } else {\n        document.getElementById(\"toggleScheduledRuns\").className = \"control\";\n    }\n\n    // Update visibility\n    this.setState({\n        scheduledRunsVisible: !this.state.scheduledRunsVisible\n    });\n};\n\n// Set refresh rate from API side if already previously set\nfunction initialiseRefreshRate() {\n    axios.get('/refresh')\n        .then((response) => {\n            this.refreshRate = response.data.refresh;\n            setInitialRefreshRate(this.refreshRate);\n        })\n        .catch(error => {\n            this.refreshRate = DEF_API_REP_FREQ;\n            setInitialRefreshRate(this.refreshRate);\n        });\n}\n\nfunction setInitialRefreshRate(refresh) {\n    displayRefresh(refresh);\n    document.getElementById(\"refreshSlider\").value = refresh;\n    this.refresh = setInterval(this.updateData, refresh * SECONDS_TO_MS);\n}\n\n// Update API rate according to slider value\nfunction updateRefresh() {\n    this.refreshRate = document.getElementById(\"refreshSlider\").value;\n    // Stop the current refresh cycle and restart with new refresh time\n    if(this.refresh != null) {\n        console.log(\"Setting new refresh rate to: \" + this.refreshRate);\n        clearInterval(this.refresh);\n        this.refresh = setInterval(this.updateData, this.refreshRate * SECONDS_TO_MS);\n    }\n\n    axios.post('/refresh', {refreshRate: this.refreshRate});\n}\n\n// Update text above slider to reflect refresh value\nfunction displayRefresh(refresh) {\n    let text = refresh + \" seconds\";\n    document.getElementById(\"refreshDisplay\").value = text;\n    document.getElementById(\"refreshDisplay\").size = text.length;\n}\n\n// Driver to update slider value during drag\nfunction displayRefreshSlider() {\n    displayRefresh(document.getElementById(\"refreshSlider\").value);\n}\n\nexport default class Map extends Component {\n    // Event handler when map is zoomed, adjusts icon sizes\n    updateData() {\n        console.log(\"Updating data...\");\n        axios.all([getRouteDescriptions(),\n                   getStationDepartures(),\n                   getRuns()])\n        .then((response) => {\n            this.setState({\n                routes: response[0].data,\n                stationDepartures: response[1].data,\n                runs: response[2].data.runs\n            });\n        });\n    }\n\n    refreshPage() {\n        this.setState({});\n    }\n\n    // Event handler when map is zoomed, adjusts icon sizes\n    handleZoom() {\n        // Determine how much to scale icons based on zoom level\n        let currZoom = this.mapRef.current.viewport.zoom;\n        let maxZoom = this.mapRef.current.props.maxZoom;\n        let vehicleSize = MAX_VEHICLE_ICON_LEN * Math.pow((currZoom / maxZoom), ICON_SCALE_FACTOR);\n        let stationSize = MAX_STATION_ICON_LEN * Math.pow((currZoom / maxZoom), ICON_SCALE_FACTOR);\n\n        // Disable station icons if they become too small (zoom too far away)\n        if(stationSize > MIN_ICON_SIZE) {\n            railIcon.options.iconSize = [stationSize, stationSize];\n        } else {\n            railIcon.options.iconSize = [0, 0];\n        }\n\n        trainIcon.options.iconSize = [vehicleSize, vehicleSize];\n        trainSideIcon.options.iconSize = [vehicleSize, vehicleSize];\n        trainSideInvertedIcon.options.iconSize = [vehicleSize, vehicleSize];\n        trainSideDelayedIcon.options.iconSize = [vehicleSize, vehicleSize];\n        trainSideInvertedDelayedIcon.options.iconSize = [vehicleSize, vehicleSize];\n\n        // Force update train icons\n        let layers = this.trainRef.current.leafletElement.getLayers();\n        for(let i in layers) {\n            layers[i].refreshIconOptions();\n        }\n\n        // Force update station icons\n        layers = this.stationRef.current.leafletElement.getLayers();\n        for(let i in layers) {\n            layers[i].refreshIconOptions();\n        }\n    };\n\n    returnStopName(stop_id) {\n        for (let i in this.state.stationDepartures) {\n            let stop = this.state.stationDepartures[i];\n            if(stop.stop_id === stop_id) {\n                return stop.stop_name;\n            }\n        }\n    }\n\n    getRouteName(route_id) {\n        for (let i in this.state.routes) {\n            if(this.state.routes[i].route_id === route_id) {\n                return this.state.routes[i].route_name;\n            }\n        }\n    }\n\n    getDirectionName(route_id, direction_id) {\n        for(let i in this.state.routes) {\n            if(this.state.routes[i].route_id === route_id) {\n                for(let j in this.state.routes[i].directions) {\n                    if(this.state.routes[i].directions[j].direction_id === direction_id) {\n                        return this.state.routes[i].directions[j].direction_name;\n                    }\n                }\n            }\n        }\n    }\n\n    // Calculate the punctuality of all departures\n    // TODO: Possibly move to backend and add API route\n    calculatePunctuality() {\n        let lateCount = 0, departureCount = 0;\n        const stations = this.state.stationDepartures;\n\n        for (let i in stations) {\n            for (let j in stations[i].departures) {\n                const estimatedTime = moment.utc(stations[i].departures[j].estimated_departure_utc);\n                const scheduledTime = moment.utc(stations[i].departures[j].scheduled_departure_utc);\n                if (!estimatedTime) continue; // Skip if estimated time not supplied\n\n                departureCount++;\n                // Count departures 5 minutes late or more\n                if (Math.abs(estimatedTime.diff(scheduledTime, 'minutes')) >= 5) {\n                    lateCount++;\n                }\n            }\n        }\n        return 100 - (lateCount * 100.00 / departureCount);\n    }\n\n    componentDidMount() {\n        this.updateData();\n        initialiseRefreshRate();\n        setInterval(this.refreshPage, 10000);\n    }\n    \n    setZoom() {\n        this.mapRef.current.props.zoom = 10\n    }\n\n    constructor(props) {\n        super(props);\n\n        // Create references to be used when updating icons\n        this.mapRef = React.createRef();\n        this.trainRef = React.createRef();\n        this.stationRef = React.createRef();\n\n        this.state = {\n            scheduledRunsVisible: false,\n            lat: -37.814,\n            lng: 144.96332,\n            zoom: 13,\n            routes: [],\n            stationDepartures: [],\n            runs: []\n        };\n\n\n        this.handleZoom = this.handleZoom.bind(this);\n        this.updateData = this.updateData.bind(this);\n        this.refreshPage = this.refreshPage.bind(this);\n        this.setZoom = this.setZoom.bind(this);\n\n        this.zoomOut = () => this.setState({zoom: this.state.zoom-1})\n        this.zoomIn = () => this.setState({zoom: this.state.zoom+1})\n\n        showScheduledRuns = showScheduledRuns.bind(this);\n        updateRefresh = updateRefresh.bind(this);\n        displayRefresh = displayRefresh.bind(this);\n        setInitialRefreshRate = setInitialRefreshRate.bind(this);\n        initialiseRefreshRate = initialiseRefreshRate.bind(this);\n    }\n\n    render() {\n        const position = [this.state.lat, this.state.lng];\n        const stations = this.state.stationDepartures;\n        const runs = this.state.runs;\n        const punctuality = this.calculatePunctuality();\n\n        return (\n            <div id='transport'>\n                <LeafletMap id=\"map\" ref={this.mapRef} scrollWheelZoom={false} center={position} zoom={this.state.zoom} maxZoom={17} onZoomEnd={this.handleZoom}>\n                    <Control position=\"topright\">\n                        {/* Render punctuality when there is data */}\n                        { !isNaN(punctuality) && <span id=\"punctualityLabel\"><small>Punctuality: </small><span id=\"bold\">{punctuality.toFixed(2)}</span> %</span> }\n                        \n                    </Control>\n                    {/* < Popup >\n                        <span >\n                            <button onClick={this.zoomOut}>\n                            Zoom out\n                            </button>\n                            < button onClick = {this.zoomIn} >\n                            Zoom in\n                            </button>\n                        </span>\n                    </Popup > */}\n                    <Control position=\"bottomleft\">\n                        <div id=\"disruptionsContainer\">\n                            Disruptions container\n                        </div>\n                        <div id=\"controlPanel\">\n                        <button onClick={ this.zoomIn } className=\"control\">Zoom in</button><br/>\n                        <button onClick={ this.zoomOut } className=\"control\">Zoom out</button><br/>\n                        <button onClick={ getDisruptions } className=\"control\">Show Disruptions</button><br/>\n                        <button onClick={ swapRouteType } className=\"control\">Switch Transport Type &#8693;</button><br/>\n                        <button onClick={ showScheduledRuns } className=\"control\" id=\"toggleScheduledRuns\">Scheduled Runs</button>\n                        <div className=\"control\" id=\"refreshBox\">\n                            Refresh Rate: <input type=\"text\" defaultValue={DEF_API_REP_FREQ + \" seconds\"} size=\"10\" id=\"refreshDisplay\" disabled/><br/>\n                            <input type=\"range\" min={MIN_API_REP_FREQ} max={MAX_API_REP_FREQ} defaultValue={DEF_API_REP_FREQ} id=\"refreshSlider\" onMouseUp={updateRefresh} onChange={displayRefreshSlider}/>\n                        </div>\n                        </div>\n                    </Control>\n                    <TileLayer\n                        attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n                        url='https://api.tiles.mapbox.com/v4/mapbox.streets/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoic2lhdzk2IiwiYSI6ImNqdHRra3FuNDFjeW00MHBjMnNveGdha2QifQ.HK8K4aseYwzjdqAStXAyxg'\n                    />\n\n                    <MarkerClusterGroup maxClusterRadius={10} ref={this.trainRef}>\n                        {\n                            runs.map((key, index) => {\n                                if(this.state.scheduledRunsVisible || runs[index].departure[runs[index].currentDeparture].estimated_departure_utc) {\n                                    let timeStamp;\n                                    let icon;\n                                    let angle;\n                                    let tooltip;\n                                    let arrivalTime;\n                                    let atPlatform = runs[index].departure[runs[index].currentDeparture].at_platform;\n                                    let runStarted = runs[index].currentDeparture > 0;\n\n\n                                    // Determine timestamp (arrival time to next stop)\n                                    if (runs[index].departure[runs[index].currentDeparture].estimated_departure_utc) {\n                                        arrivalTime = moment.utc(runs[index].departure[runs[index].currentDeparture].estimated_departure_utc);\n                                    } else {\n                                        arrivalTime = moment.utc(runs[index].departure[runs[index].currentDeparture].scheduled_departure_utc);\n                                    }\n                                    timeStamp = arrivalTime.diff(moment.utc(), 'minutes');\n\n                                    const previousStopCoordinates = runs[index].coordinates.previousStopCoordinates;\n                                    const nextStopCoordinates = runs[index].coordinates.nextStopCoordinates;\n\n                                    // Set appropriate icons for trains and their properties\n                                    if (atPlatform || !runStarted) {\n                                        runs[index].currentCoordinates = runs[index].coordinates.nextStopCoordinates;\n                                        angle = 0;\n                                        icon = trainIcon;\n                                    } else {\n                                        // Trains currently travelling between stations\n                                        let scalar;\n                                        let timeStampSeconds = arrivalTime.diff(moment.utc(), 'seconds');\n\n                                        // Calculation for determining current position of vehicle between two stops\n                                        let prevDeparture = runs[index].departure[runs[index].currentDeparture - 1];\n                                        let nextDeparture = runs[index].departure[runs[index].currentDeparture];\n                                        const time1 = moment.utc(prevDeparture.estimated_departure_utc ? prevDeparture.estimated_departure_utc : prevDeparture.scheduled_departure_utc);\n                                        const time2 = moment.utc(nextDeparture.estimated_departure_utc ? nextDeparture.estimated_departure_utc : nextDeparture.scheduled_departure_utc);\n                                        const travelTime = Math.abs(time2.diff(time1, 'seconds'));\n                                        if(timeStamp >= 0) {\n                                            scalar = timeStampSeconds / travelTime;\n                                        } else {\n                                            // Do not allow vehilces to go past next stop\n                                            // if expected arrival time has passed\n                                            scalar = 0;\n                                        }\n\n                                        // Check if on time\n                                        const estimatedTime = moment.utc(nextDeparture.estimated_departure_utc);\n                                        const scheduledTime = moment.utc(nextDeparture.scheduled_departure_utc);\n\n                                        let late = estimatedTime.diff(scheduledTime, 'minutes') >= 5;\n                                        runs[index].currentCoordinates = Departures.determineRunCoordinates(scalar, previousStopCoordinates, nextStopCoordinates);\n                                        angle = Departures.calculateAngle(previousStopCoordinates, nextStopCoordinates);\n                                        if (nextStopCoordinates[0] < previousStopCoordinates[0]) {\n                                            angle += 90;\n                                            icon = late && estimatedTime ? trainSideDelayedIcon : trainSideIcon; // Don't render trains without an estimated time (real-time) as late\n                                        } else {\n                                            angle += 90;\n                                            icon = late && estimatedTime ? trainSideInvertedDelayedIcon : trainSideInvertedIcon;\n                                        }\n                                    }\n\n                                    // Determine future stop time arrivals (timetable on mouseover / click)\n                                    let filteredDepartures = runs[index].departure;\n                                    let filteredDetails = [];\n\n                                    for (let i in filteredDepartures) {\n                                        let departureTime;\n                                        if(filteredDepartures[i].estimated_departure_utc) {\n                                            departureTime = moment.utc(filteredDepartures[i].estimated_departure_utc);\n                                        } else {\n                                            departureTime = moment.utc(filteredDepartures[i].scheduled_departure_utc);\n                                        }\n                                        const differenceInTime = departureTime.diff(moment.utc(), 'minutes');\n                                        const stopName = this.returnStopName(filteredDepartures[i].stop_id);\n                                        if(differenceInTime >= 0 || i == runs[index].currentDeparture) {\n                                            filteredDetails.push({\n                                                stopName: stopName,\n                                                differenceInTime: differenceInTime\n                                            });\n                                        }\n                                    }\n\n                                    // Get previous station name\n                                    let prevStation;\n                                    if(runStarted) {\n                                        prevStation = this.returnStopName(runs[index].departure[runs[index].currentDeparture - 1].stop_id);\n                                    } else {\n                                        prevStation = \"None\";\n                                    }\n\n                                    // Rendering flags\n                                    let beginningRun = atPlatform && !runStarted;\n                                    let stoppedAtStation = atPlatform && runStarted;\n\n                                    tooltip = <Tooltip>\n                                        <div><strong> {this.getRouteName(runs[index].departure[runs[index].currentDeparture].route_id)} </strong></div>\n                                        <div><strong>(to {this.getDirectionName(runs[index].departure[runs[index].currentDeparture].route_id,\n                                            runs[index].coordinates.direction_id)})</strong></div>\n                                        <div><strong>Run ID:</strong> {runs[index].departure[runs[index].currentDeparture].run_id}</div>\n                                        {beginningRun &&\n                                            <div><strong>Next Stop:</strong> {this.returnStopName(runs[index].departure[runs[index].currentDeparture].stop_id)}<br/>\n                                            <strong>Departure Time:</strong> {timeStamp} min</div>\n                                        }\n                                        {stoppedAtStation &&\n                                            <div><strong>At {this.returnStopName(runs[index].departure[runs[index].currentDeparture].stop_id)}</strong><br/></div>\n                                        }\n                                        {runStarted &&\n                                            <div><strong>Previous Stop:</strong> {prevStation}<br/>\n                                            <strong>Next Stop:</strong> {this.returnStopName(runs[index].departure[runs[index].currentDeparture].stop_id)}<br/>\n                                            <strong>Arrival Time:</strong> {timeStamp} min</div>\n                                        }\n                                    </Tooltip>;\n\n                                    // Condition ignores trains that have not arrived at their first scheduled stop\n                                    if (atPlatform || runStarted) {\n                                        return <RotatedMarker icon={icon} position={runs[index].currentCoordinates} rotationAngle={angle} rotationOrigin={'center'}>\n                                            <Popup>\n                                                {\n                                                    filteredDetails.map((key, index3) => {\n                                                        return <div>\n                                                            <strong>{filteredDetails[index3].differenceInTime}</strong> minutes -> <strong>{filteredDetails[index3].stopName}</strong>\n                                                            <br />\n                                                        </div>\n                                                    })\n                                                }\n                                            </Popup>\n                                            {tooltip}\n                                        </RotatedMarker>\n                                    }\n                                }\n                            })\n                        }\n                    </MarkerClusterGroup>\n\n                    <LayerGroup ref={this.stationRef}>\n                        {\n                            stations.map((key, index) => {\n                                // Render each station with name and departures\n                                const coordinates = [stations[index].stop_latitude, stations[index].stop_longitude];\n\n                                return <Marker icon={railIcon} position={coordinates}>\n                                    <Tooltip>\n                                        <strong>{stations[index].stop_name} (Stop ID: {stations[index].stop_id})</strong><br/>\n                                        {\n                                            stations[index].departures.map((key, index2) => {\n                                                let time;\n                                                // Calculated time arrival and render on tooltip\n                                                if(stations[index].departures[index2].estimated_departure_utc) {\n                                                    time = moment.utc(stations[index].departures[index2].estimated_departure_utc);\n                                                    let timeStamp = time.diff(moment.utc(), 'minutes');\n\n                                                    if(timeStamp >= 0) {\n                                                        // Calculate difference in estimated and scheduled time\n                                                        let schedule = \"\";\n                                                        const estimatedTime = moment.utc(stations[index].departures[index2].estimated_departure_utc);\n                                                        const scheduledTime = moment.utc(stations[index].departures[index2].scheduled_departure_utc);\n                                                        let diff = estimatedTime.diff(scheduledTime, 'minutes');\n                                                        if (stations[index].departures[index2].estimated_departure_utc && diff > 0) {\n                                                            let highlight = diff >= 10 ? \"very-late-highlight\" : diff >= 5 ? \"late-highlight\" : \"behind-highlight\";\n                                                            schedule = <mark id={highlight}>{'(' + diff + ' min late)'}</mark>;\n                                                        }\n\n                                                        return <div>\n                                                            <strong>(Estimated)</strong> {this.getRouteName(stations[index].departures[index2].route_id) + \" \"}\n                                                                (to {this.getDirectionName(stations[index].departures[index2].route_id,\n                                                                stations[index].departures[index2].direction_id)}) -> {timeStamp} mins {schedule}<br/>\n                                                        </div>\n                                                    }\n                                                } else if(this.state.scheduledRunsVisible) {\n                                                    time = moment.utc(stations[index].departures[index2].scheduled_departure_utc);\n                                                    let timeStamp = time.diff(moment.utc(), 'minutes');\n\n                                                    if(timeStamp >= 0) {\n                                                    return <div>\n                                                    (Scheduled) {this.getRouteName(stations[index].departures[index2].route_id) + \" \"}\n                                                            (to {this.getDirectionName(stations[index].departures[index2].route_id,\n                                                            stations[index].departures[index2].direction_id)}) -> {timeStamp} mins<br/>\n                                                        </div>\n                                                    }\n                                                }\n                                            })\n                                        }\n                                    </Tooltip>\n                                </Marker>\n                            })\n                        }\n                    </LayerGroup>\n                </LeafletMap>\n            </div>\n        );\n    }\n}","import React from 'react';\nimport { Button, Card, CardBody, Input, InputGroup, InputGroupAddon } from 'reactstrap';\n\nimport './Debug.css';\n\nconst axios = require('axios');\nconst moment = require('moment');\n\nexport default class Debug extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            departures: [],\n            stops: [],\n            runID: '',\n            stopID: '',\n            routeID: '',\n            result1: '',\n            result2: '',\n            result3: '',\n        };\n    }\n\n    sortDeparturesBasedOnTime(a, b) {\n        const aTime = moment.utc(a.estimated_departure_utc);\n        const bTime = moment.utc(b.estimated_departure_utc);\n\n        let comparison = 0;\n        if (aTime.isAfter(bTime)) {\n            comparison = 1;\n        } else if (aTime.isBefore(bTime)) {\n            comparison = -1;\n        }\n\n        return comparison;\n    }\n\n    handleChangeRunID(event) {\n        this.setState({\n            runID: event.target.value\n        });\n    }\n\n    handleChangeStopID(event) {\n        this.setState({\n            stopID: event.target.value\n        });\n    }\n\n    handleChangeRouteID(event) {\n        this.setState({\n            routeID: event.target.value\n        });\n    }\n\n    returnDepartures(runID) {\n        let departures = [];\n        for (let i in this.state.departures) {\n            for (let j in this.state.departures[i]) {\n                for (let k in this.state.departures[i][j]) {\n                    if (this.state.departures[i][j][k].run_id === runID) {\n                        departures.push(this.state.departures[i][j][k]);\n                    }\n                }\n            }\n        }\n        departures.sort(this.sortDeparturesBasedOnTime);\n        console.log(departures);\n\n        let filteredDepartures = [];\n        const currentTime = moment.utc();\n\n        for (let i in departures) {\n            const departureTime = moment.utc(departures[i].estimated_departure_utc);\n            const differenceInTime = Math.abs(departureTime.diff(currentTime, 'minutes'));\n            const stopName = this.returnStopName(departures[i].stop_id);\n            filteredDepartures.push(stopName, differenceInTime);\n        }\n\n        const result = [];\n        result.push(departures);\n        result.push(filteredDepartures);\n\n        this.setState({\n            result1: result\n        });\n\n\n    }\n\n    returnStopInformation(stopID) {\n        for (let i in this.state.stops) {\n            for (let j in this.state.stops[i]) {\n                if (this.state.stops[i][j].stop_id === stopID) {\n                    this.setState({\n                        result2: this.state.stops[i][j]\n                    });\n                }\n            }\n        }\n    }\n\n    returnStopName(stopID) {\n        for (let i in this.state.stops) {\n            for (let j in this.state.stops[i]) {\n                if (this.state.stops[i][j].stop_id === stopID) {\n                    return this.state.stops[i][j].stop_name;\n                }\n            }\n        }\n    }\n\n    returnStops(routeID) {\n        for (let i in this.state.stops) {\n            if (this.state.stops[i][0].route_id === routeID) {\n                this.setState({\n                    result3: this.state.stops[i]\n                });\n            }\n        }\n    }\n\n    componentDidMount() {\n        axios.get(\"/api/stops\")\n            .then(response => {\n                this.setState({\n                    stops: response.data\n                });\n            })\n\n        axios.get(\"/api/departures\")\n            .then(response => {\n                this.setState({\n                    departures: response.data\n                });\n            })\n\n        setInterval(() => {\n            axios.get(\"/api/stops\")\n                .then(response => {\n                    this.setState({\n                        stops: response.data\n                    });\n                })\n\n            axios.get(\"/api/departures\")\n                .then(response => {\n                    this.setState({\n                        departures: response.data\n                    });\n                })\n        }, 5000)\n    }\n\n    render() {\n        const stops = this.state.stops;\n        const departures = this.state.departures;\n\n        // console.log(this.state.stops);\n\n        return (\n            <div className=\"col text-center\">\n                <InputGroup className=\"center\">\n                    <Input placeholder=\"Return departures for the run id\" value={this.state.runID} onChange={evt => this.handleChangeRunID(evt)} />\n                    <Button onClick={() => this.returnDepartures(parseInt(this.state.runID))} color=\"info\" className=\"btn btn-default\">Submit</Button>\n                </InputGroup>\n                <Card className=\"center\">\n                    <CardBody>\n                        <div><pre>{JSON.stringify(this.state.result1, null, 1)}</pre></div>\n                    </CardBody>\n                </Card>\n                <InputGroup className=\"center\">\n                    <Input placeholder=\"Return stop information with the stop ID\" value={this.state.stopID} onChange={evt => this.handleChangeStopID(evt)} />\n                    <Button onClick={() => this.returnStopInformation(parseInt(this.state.stopID))} color=\"info\" className=\"btn btn-default\">Submit</Button>\n                </InputGroup>\n                <Card className=\"center\">\n                    <CardBody>\n                        <div><pre>{JSON.stringify(this.state.result2, null, 1)}</pre></div>\n                    </CardBody>\n                </Card>\n                <InputGroup className=\"center\">\n                    <Input placeholder=\"Return stops for the route id\" value={this.state.routeID} onChange={evt => this.handleChangeRouteID(evt)} />\n                    <Button onClick={() => this.returnStops(parseInt(this.state.routeID))} color=\"info\" className=\"btn btn-default\">Submit</Button>\n                </InputGroup>\n                <Card className=\"center\">\n                    <CardBody>\n                        <div><pre>{JSON.stringify(this.state.result3, null, 1)}</pre></div>\n                    </CardBody>\n                </Card>\n            </div>\n        )\n    }\n}","import React, { Component } from 'react';\nimport { Route, BrowserRouter } from \"react-router-dom\";\nimport { SAGE2App, useSAGE2AppStateValue } from \"./useSAGE2AppState\";\n\n// import logo from './logo.svg';\nimport './App.css';\n\nimport Map from './views/Map/Map';\nimport Debug from './views/Debug/Debug';\n\n\nclass App extends Component {\n  render() {\n    return (\n      <SAGE2App\n        initialState={{\n          mapZoom: 0,\n        }}\n      >\n        <ZoomUsingState />\n        <BrowserRouter basename={window.location.pathname || ''}>\n          <Route exact path=\"/\" component={() => <Map zoom={this.props.mapZoom} />} />\n          <Route path=\"/debug\" component={Debug} />\n        </BrowserRouter>\n      </SAGE2App>\n    );\n  }\n}\n\nfunction ZoomUsingState() {\n  let [mapZoom, setCount] = useSAGE2AppStateValue(\"mapZoom\");\n\n  console.log(\"app state\", mapZoom);\n  // var styles = '#zoom-block { position: absolute }';\n\n  return (\n    <div id=\"zoom-block\">\n      Zoom: {mapZoom}\n      <button onClick={() => setCount(mapZoom + 1)}>+</button>\n      <button onClick={() => setCount(mapZoom - 1)}>-</button>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nrequire(\"./SAGE2_AppState\");\n\nReactDOM.render(\n    <BrowserRouter>\n        <App />\n    </BrowserRouter>\n    , document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","//\n// SAGE2 application: skeletonWebviewApp\n// by: Dylan Kobayashi <dylank@hawaii.edu>\n//\n// Copyright (c) 2018\n//\n\n/**\nUsage:\n  Pass back information to the SAGE2 application using setValue()\n    It takes two parameters: nameOfValue and value\n    Specify the name of the state variables with nameOfValue\n      It needs to match a top level variable specified in the instructions.json file\n    Then, value is what it will be assigned in the application\n  \n  Handle value updates by addiing callbacks to the addValueHandler()\n    It takes two paramters: nameOfValue and callback\n    When the app issues updates the callback will be activated through handleValue()\n    All load varibles specified in instructions.json should be given a handler\n    Currently only one handler is allowed per value.\n\n\n\n\n    Some default values that are provided to help with tracking changes:\n      status\n\n*/\nconst SAGE2_AppState = {\n  // Tracks Value Handlers. At the moment only supports one callback per value.\n  valueHandlers: {},\n  fullStateCallback: null,\n  // Should be low overhead. For now will track the last value given by app.\n  valueTracker: {},\n  // Updates when the state is given\n  state: null,\n\n  /**\n   * Adds a handler for the given nameOfValue.\n   *\n   * @method addValueHandler\n   * @param {String} nameOfValue - name of value on server to set.\n   * @param {Function} callback - function to call when receiving a value update from app.\n   */\n  addValueHandler: function (nameOfValue, callback) {\n    this.valueHandlers[nameOfValue] = callback;\n  },\n\n  /**\n   * Adds a handler for the given nameOfValue.\n   *\n   * @method addFullStateHandler\n   * @param {String} nameOfValue - name of value on server to set.\n   * @param {Function} callback - function to call when receiving a value update from app.\n   */\n  addFullStateHandler: function (callback) {\n    this.fullStateCallback = callback;\n  },\n\n  /**\n   * Sends value back to app to update the state variable.\n   *\n   * @method setValue\n   * @param {String} nameOfValue - name of value on server to set\n   * @param {Any} value - the value to store for this variable\n   * @param {Boolean} propagateChanges - true will send values to all other app instances (usually remote sites), false will hold off.\n   */\n  setValue: function (nameOfValue, value, propagateChanges = true) {\n    let setValueMessage = {\n      s2: \"state\",\n      nameOfValue,\n      value,\n      propagateChanges,\n    };\n    this.send(setValueMessage);\n  },\n\n  /**\n   * Sends message to update title.\n   *\n   * @method titleUpdate\n   * @param {String} title - new title for app to display.\n   */\n  titleUpdate: function (title) {\n    this.callFunctionInContainer(\"changeWebviewTitle\", title);\n  },\n\n  /**\n   * Called by the application container to fully update the state in one pass.\n   * It is up to the user to handle cases where the state is updated with the same values.\n   *\n   * @method fullStateHandler\n   * @param {Object} state - Received state from the container\n   */\n  fullStateHandler: function (state) {\n    this.state = state;\n    if (this.fullStateCallback) {\n      this.fullStateCallback(state);\n    }\n    const keys = Object.keys(state);\n    for (let i = 0; i < keys.length; i++) {\n      this.handleValue(keys[i], state[keys[i]]);\n    }\n  },\n\n  /**\n   * Usually called by fullStateHandler, but can also be called by application to update a single value.\n   * The callbacks set by addValueHandler will be called here.\n   * Passes the value to the function.\n   *\n   * @method handleValue\n   * @param {String} nameOfValue - name of state property\n   * @param {Any} value - the value given for that property\n   */\n  handleValue: function (nameOfValue, value) {\n    this.valueTracker[nameOfValue] = value;\n    if (this.valueHandlers[nameOfValue]) {\n      this.valueHandlers[nameOfValue](value);\n    }\n    // else {\n    //   let warnMissing = {\n    //     s2: \"status\",\n    //     value: \"Given nameOfValue (\" + nameOfValue +\") doesn't have a handler\",\n    //   };\n    //   this.send(warnMissing);\n    // }\n  },\n\n  /**\n   * Calls a function in the container, must exist. Takes an optional parameter\n   *\n   * @method callFunctionInContainer\n   * @param {String} nameOfFunction - name of function on container\n   * @param {Any} value - One param to pass, if want to pass more, send an object\n   */\n  callFunctionInContainer: function (nameOfFunction, value) {\n    let message = {\n      s2: \"functionCall\",\n      nameOfFunction,\n      value: value,\n    };\n    this.send(message);\n  },\n\n  /**\n   * Prints the data to console to match\n   *\n   * @method send\n   * @param {Object} message - message to send back to application using the console.\n   */\n  send: function (message) {\n    console.log(JSON.stringify(message));\n  },\n};\n\n// attach to window to connect with webview core\nwindow.SAGE2_AppState = SAGE2_AppState;\nexport default SAGE2_AppState;\n","module.exports = __webpack_public_path__ + \"static/media/train_side_delayed.bc281abc.svg\";","module.exports = __webpack_public_path__ + \"static/media/train_side_inverted_delayed.0d7c9d90.svg\";","module.exports = __webpack_public_path__ + \"static/media/rail2.ed9c2746.svg\";","module.exports = __webpack_public_path__ + \"static/media/train.db47e899.png\";","module.exports = __webpack_public_path__ + \"static/media/train_side.d63cb63b.svg\";","module.exports = __webpack_public_path__ + \"static/media/train_side_inverted.1d219bf8.svg\";"],"sourceRoot":""}